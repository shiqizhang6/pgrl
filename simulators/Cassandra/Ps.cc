// $Id: makeOptionsFromDefines.cc.template,v 1.10 2004/08/17 07:39:45 daa Exp $ 
// Automatically generated by makeOptionsFromDefines. Do not edit .cc file.
// Edit .cc.template file instead.

using namespace std;

#include <stdlib.h>    /* for exit */
#include <string.h>
#include <getopt.h>
#include <iostream>
#include <fstream>
#include <assert.h>
#include "Ps.hh"

#ifndef MAX_STRING
#define MAX_STRING 1024
#endif

#define PsCOMMENT_CHAR '#'
#define PsHELP 0xfffe
#define PsCONFIG 0xffff

int Ps::numOptions = 19;

// Initial values for parameters
char* Ps::pMODE = strdup("BELIEF");
char* Ps::pPARAM_FILE = strdup("Cassandra.params");
char* Ps::pPROBLEM_FILE = strdup("");
double Ps::pPENALTY = 0.0;
double Ps::pSTEP_SIZE = 0.0001;
int Ps::pSTEPS_PER_EPOCH = 50;
int Ps::pMAX_STEPS = 0;
int Ps::pMAX_TIME = 0;
int Ps::pHIDDEN = 0;
double Ps::pMAX_RAND_PARAM = 0.00;
double Ps::pTD_DISCOUNT = 0.75;
double Ps::pPSR_STEP_SIZE = 1.0;
int Ps::pMAX_HISTORY = 1000;
int Ps::pMAX_CORE_TESTS = 6;
double Ps::pMIN_KAPPA_FOR_CORE = 10000.0;
int Ps::pPASSES_BEFORE_ADDCORES = 3;
int Ps::pMEM_MAX_HISTORY = 2;
int Ps::pHMM_MAX_HISTORY = 1000;
int Ps::pHMM_WINDOW = 0;


// Structure to do dynamic variable sets and gets by string name
Ps::OptionReflect Ps::reflections[] = {
    {strdup("MODE"),
     strdup("default=Owens table, MEM=finite memory, PSR=psr, HMM, CHEAT, BELIEF, EXACT_PSR"),
     PsString,
     &Ps::pMODE
    },
    {strdup("PARAM_FILE"),
     strdup("Save parameters here."),
     PsString,
     &Ps::pPARAM_FILE
    },
    {strdup("PROBLEM_FILE"),
     strdup("If not specified without option on command line"),
     PsString,
     &Ps::pPROBLEM_FILE
    },
    {strdup("PENALTY"),
     strdup("Quadratic (Tikhonov) penalty term"),
     PsDouble,
     &Ps::pPENALTY
    },
    {strdup("STEP_SIZE"),
     strdup("0.00001 // Gradient step size, a.k.a., alpha"),
     PsDouble,
     &Ps::pSTEP_SIZE
    },
    {strdup("STEPS_PER_EPOCH"),
     strdup("10000 // Steps per epoch. Has implications for baseline estimation"),
     PsInt,
     &Ps::pSTEPS_PER_EPOCH
    },
    {strdup("MAX_STEPS"),
     strdup("If this is >0 stop at this many steps"),
     PsInt,
     &Ps::pMAX_STEPS
    },
    {strdup("MAX_TIME"),
     strdup("If this is >0 stop after this time (seconds)"),
     PsInt,
     &Ps::pMAX_TIME
    },
    {strdup("HIDDEN"),
     strdup("includes input dimension and output dimension"),
     PsInt,
     &Ps::pHIDDEN
    },
    {strdup("MAX_RAND_PARAM"),
     strdup("maximum initial param value. For NN_LAYERS>2 cannot be 0"),
     PsDouble,
     &Ps::pMAX_RAND_PARAM
    },
    {strdup("TD_DISCOUNT"),
     strdup("0.25 // Value estimate discount, a.k.a., gamma"),
     PsDouble,
     &Ps::pTD_DISCOUNT
    },
    {strdup("PSR_STEP_SIZE"),
     strdup("PSR learning rate"),
     PsDouble,
     &Ps::pPSR_STEP_SIZE
    },
    {strdup("MAX_HISTORY"),
     strdup("Size of PSR history matrix"),
     PsInt,
     &Ps::pMAX_HISTORY
    },
    {strdup("MAX_CORE_TESTS"),
     strdup("Default is counted as a core test."),
     PsInt,
     &Ps::pMAX_CORE_TESTS
    },
    {strdup("MIN_KAPPA_FOR_CORE"),
     strdup("Minumum condition number for a proposed new ccore test."),
     PsDouble,
     &Ps::pMIN_KAPPA_FOR_CORE
    },
    {strdup("PASSES_BEFORE_ADDCORES"),
     strdup("Restimate history matrix this number of times before doing core test addition."),
     PsInt,
     &Ps::pPASSES_BEFORE_ADDCORES
    },
    {strdup("MEM_MAX_HISTORY"),
     strdup(""),
     PsInt,
     &Ps::pMEM_MAX_HISTORY
    },
    {strdup("HMM_MAX_HISTORY"),
     strdup("How much history used for re-estimating model ?"),
     PsInt,
     &Ps::pHMM_MAX_HISTORY
    },
    {strdup("HMM_WINDOW"),
     strdup("How much history used for estimating state ? (0 -> =HMM_MAX_HISTORY )"),
     PsInt,
     &Ps::pHMM_WINDOW
    },
    {NULL, NULL, PsInt, NULL}
};


// Process command line args that may contain parameters.
// INPUT: normal argv, argc from command line
// OUTPUT: Current optind for processing remainder of options
int Ps::processOpts(int argc, char **argv) {
    int c;
    
    while (1) {
	int option_index = 0;
	static struct option long_options[] = {
            {"MODE", 1, 0, 0},
            {"PARAM_FILE", 1, 0, 1},
            {"PROBLEM_FILE", 1, 0, 2},
            {"PENALTY", 1, 0, 3},
            {"STEP_SIZE", 1, 0, 4},
            {"STEPS_PER_EPOCH", 1, 0, 5},
            {"MAX_STEPS", 1, 0, 6},
            {"MAX_TIME", 1, 0, 7},
            {"HIDDEN", 1, 0, 8},
            {"MAX_RAND_PARAM", 1, 0, 9},
            {"TD_DISCOUNT", 1, 0, 10},
            {"PSR_STEP_SIZE", 1, 0, 11},
            {"MAX_HISTORY", 1, 0, 12},
            {"MAX_CORE_TESTS", 1, 0, 13},
            {"MIN_KAPPA_FOR_CORE", 1, 0, 14},
            {"PASSES_BEFORE_ADDCORES", 1, 0, 15},
            {"MEM_MAX_HISTORY", 1, 0, 16},
            {"HMM_MAX_HISTORY", 1, 0, 17},
            {"HMM_WINDOW", 1, 0, 18},
            // End of auto ops
            {"help", 0, 0, PsHELP},
            {"config", 1, 0, PsCONFIG},
            {"?", 0, 0, PsHELP},
            {0, 0, 0, 0}
	};
	
	c = getopt_long(argc, argv, "", long_options, &option_index);
	if (c == -1) break;

	if (c == '?' && strcmp(argv[optind-1], long_options[c].name)!=0) {
            help();
            exit(0);
        }

	switch (c) {
            case 0:
                free(pMODE);
                pMODE = strdup(optarg);
                break;
            case 1:
                free(pPARAM_FILE);
                pPARAM_FILE = strdup(optarg);
                break;
            case 2:
                free(pPROBLEM_FILE);
                pPROBLEM_FILE = strdup(optarg);
                break;
            case 3:
                pPENALTY = atof(optarg); break;
            case 4:
                pSTEP_SIZE = atof(optarg); break;
            case 5:
                pSTEPS_PER_EPOCH = atoi(optarg); break;
            case 6:
                pMAX_STEPS = atoi(optarg); break;
            case 7:
                pMAX_TIME = atoi(optarg); break;
            case 8:
                pHIDDEN = atoi(optarg); break;
            case 9:
                pMAX_RAND_PARAM = atof(optarg); break;
            case 10:
                pTD_DISCOUNT = atof(optarg); break;
            case 11:
                pPSR_STEP_SIZE = atof(optarg); break;
            case 12:
                pMAX_HISTORY = atoi(optarg); break;
            case 13:
                pMAX_CORE_TESTS = atoi(optarg); break;
            case 14:
                pMIN_KAPPA_FOR_CORE = atof(optarg); break;
            case 15:
                pPASSES_BEFORE_ADDCORES = atoi(optarg); break;
            case 16:
                pMEM_MAX_HISTORY = atoi(optarg); break;
            case 17:
                pHMM_MAX_HISTORY = atoi(optarg); break;
            case 18:
                pHMM_WINDOW = atoi(optarg); break;
            // End of auto cases 
            case PsHELP:
                help();
                exit(EXIT_SUCCESS); 
		break; // Unreachable
	    case PsCONFIG:
		parseOptionsFile(optarg);
		break;
	    default:
	        cout<<"!! Unrecognised option "<<c<<endl;
                help();
		exit(0); 
	        return c;
	}
	
    }

    return optind; // Unreachable
}


// Gets the value of an option by name. No type checking.
// Quite slow. Use the static vals if name known.
// INPUT : name of option
// OUTPUT: void* pointer to val, or NULL if no option found.
void* Ps::getVal(char* s) {

    for (int i=0; i < numOptions; i++) {
	if (strcmp(reflections[i].name, s) == 0) return reflections[i].val;
    }

    return NULL;
}


// Sets the value of an option by name. No type checking.
// Quite slow. Use the static vals if name known. Note that there is 
// no support for adding new variables, only changing the vals of
// existing vars. Note in particular, if changing string val, the
// previous string should be gotten first, and the memory asscociate
// with it freed. setValFromString() does this for you.
// INPUT : name of option
// INPUT : void* val to set. For strings, this is a char**
// OUTPUT: true on success, false if no option of that name exists. 
bool Ps::setVal(char* s, void* val) {

    for (int i=0; i < numOptions; i++) {
	if (strcmp(reflections[i].name, s) == 0) {
	    switch (reflections[i].type) {
	    case PsInt: 
		*(int*)(reflections[i].val) = *(int*)val; 
		return true;
	    case PsDouble: 
		*(double*)(reflections[i].val) = *(double*)val; 
		return true;
	    case PsString: 
		free(*(char**)(reflections[i].val));
	        *(char**)(reflections[i].val) = strdup(*(char**)val); 
		return true;
	    case PsBool:
		if (*(bool*)val) {
		    *(bool*)(reflections[i].val) = true;
		} else  *(bool*)(reflections[i].val) = false;
		return true;
	    default: cout<<"Bad type "<<reflections[i].type;
	    }
	}
    }
    return false;
}


// Set the value of a parameter from the string representation of
// the value. Takes care of freeing previous string memory if the
// type is a string. Cannot be used to declare a new variable.
// INPUT : name of option
// INPUT : value of option
// OUTPUT: true on success, false if no option of that name exists. 
bool Ps::setValFromChar(const char* s, const char* val) {

    for (int i=0; i < numOptions; i++) {
	if (strcmp(reflections[i].name, s) == 0) {
	    switch (reflections[i].type) {
	    case PsInt: 
		*(int*)(reflections[i].val) = atoi(val);
		return true;
	    case PsDouble: 
		*(double*)(reflections[i].val) = atof(val); 
		return true;
	    case PsString: 
		free(*(char**)reflections[i].val);
	        *(char**)(reflections[i].val) = strdup(val); 
		return true;
	    case PsBool:
		if (strcasecmp(val,"true")==0 || strcasecmp(val,"yes")==0) {
		    *(bool*)(reflections[i].val) = true;
		} else  *(bool*)(reflections[i].val) = false;
		return true;
	    default: cout<<"Bad type "<<reflections[i].type;
	    }
	}
    }
    return false;
}

   
// Generate options help.
void Ps::help() {
    cout<<"Valid options are (may also use unambiguous prefixes):\n";
    for (int i=0; i < numOptions; i++) {
	cout<<"--"
	    <<reflections[i].name
	    <<" : "
	    <<reflections[i].help
	    <<" (currently ";
	switch (reflections[i].type) {
	    case PsInt: cout<<*(int*)(reflections[i].val); break;
	    case PsDouble: cout<<*(double*)(reflections[i].val); break;
	    case PsString: cout<<*(char**)(reflections[i].val); break;
  	    case PsBool: 
		if (*(bool*)(reflections[i].val) == true) {
		    cout<<"true";
 	        } else cout<<"false";
	        break;
	    default: cout<<"Bad type "<<reflections[i].type;
	}
	cout<<")"<<endl;
    }
    cout<<"--config : parse a file with name=value option pairs.\n";
    cout<<"--help : display this message.\n\n"; 		
}


// Dump option values
void Ps::print(ostream& out) {

    for (int i=0; i < numOptions; i++) {
	out<<reflections[i].name
	   <<"=";
	switch (reflections[i].type) {
	    case PsInt: out<<*(int*)(reflections[i].val); break;
	    case PsDouble: out<<*(double*)(reflections[i].val); break;
	    case PsString: out<<*(char**)(reflections[i].val); break;
  	    case PsBool: 
		if (*(bool*)(reflections[i].val) == true) {
		    out<<"true";
 	        } else out<<"false";
	        break;
	    default: out<<"Bad type "<<reflections[i].type;
	}
	out<<endl;
    }
}


// Parse a file that contains options
// INPUT : filename
// OUTPUT: Number of options read successfully from file
int Ps::parseOptionsFile(char* fname) {

    char line[MAX_STRING];
    char* name;
    char* val;
    char* end;
    int linec = 0;
    int optCount = 0;

    ifstream input(fname);
    if (!input) {
	cout << "!! Could not open options file "<<fname<<endl;
	exit(EXIT_FAILURE);
    }

    // Parse each line
    while (!input.eof()) {
	input.getline(line, MAX_STRING);
	linec++;
	end = line;
	while (isspace(*end) && *end!='\0') end++;
	// Ignore blank lines and comment lines
	if (*end == '\0' || *end == PsCOMMENT_CHAR) continue;
	name = end;
	end++;
	while ((isalpha(*end) || isdigit(*end) || *end=='_') && *end != '\0') {
	    end++;
	}
	if (*end=='\0') {
	    // Line has ended before a value was parsed
	    cout<<"!! Parse error in name "<<fname<<":"<<linec<<endl;
	    continue;
	}
	*end='\0';
	end++;
	while ((isspace(*end) || *end=='=') && *end!='\0') end++;
	if (*end=='\0') {
	    // Line has ended before a value was parsed
	    cout<<"!! Parse error before val "<<fname<<":"<<linec<<endl;
	    continue;
	}
	val = end;
	end++;
	while (!isspace(*end) && *end!='#' && *end!='\0') end++;
	*end='\0';
	// If we get here, we've parsed a name and value
	if (!setValFromChar(name, val)) {
	    cout<<"!!Option '"<<name<<"' unknown in "<<fname<<":"<<linec<<endl;
	} 
	else optCount++; // Successfully added an opt
    }
   
    input.close();
    return optCount;
}

// End of auto generated file
